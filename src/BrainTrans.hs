module BrainTrans ( runCompiler ) where

import Control.Monad
import Control.Monad.Trans.State.Lazy
import Control.Monad.IO.Class
import System.FilePath
import System.IO
import System.Process


data Global = Global {
  hand :: Handle,
  tabs :: Int,
  input :: String
}

type GlobalState = StateT Global IO

incrementTabs :: GlobalState ()
incrementTabs = do
  glob <- get
  let newTabs = (tabs glob) + 1
  put $ glob {tabs = newTabs}

decrementTabs :: GlobalState ()
decrementTabs = do
  glob <- get
  let newTabs = (tabs glob) - 1
  put $ glob {tabs = newTabs}

changeHandle :: Handle -> GlobalState ()
changeHandle han = do
  glob <- get
  put $ glob {hand = han}

printLine :: String -> GlobalState ()
printLine str = do
  glob <- get
  let softtabs = replicate (2 * (tabs glob)) ' '
  liftIO $ hPutStrLn (hand glob) (softtabs ++ str)

printInitialComments :: GlobalState ()
printInitialComments = do
  printLine "/* Brainfuck C code autogenerated by BrainTrans by Allonsy"
  printLine " * For questions or concerns please contact allonsy on github */"

printIncludes :: GlobalState ()
printIncludes = do
  printLine "#include <stdlib.h>"
  printLine "#include <stdio.h>"

printAllocateArray :: GlobalState ()
printAllocateArray = do
  printLine "char *arr = calloc(30000, 1);"
  printLine "if(arr == NULL) {"
  incrementTabs
  printLine "printf(\"Allocation failed, if your computer is under memory strain please use the interpreter instead\\n\");"
  printLine "exit(1);"
  decrementTabs
  printLine "}"

isEnd :: GlobalState Bool
isEnd = do
  glob <- get
  return $ (input glob) == []

consumeInput :: GlobalState Char
consumeInput = do
  glob <- get
  let str = input glob
  put $ glob {input = tail str}
  return $ head str

accepted :: String
accepted = ".,+-><[]"

format :: String -> String
format = filter (\x -> x `elem` accepted)

printChar :: Char -> GlobalState ()
printChar '.' = printLine "putchar(arr[pos]);"
printChar ',' = printLine "arr[pos] = getchar();"
printChar '+' = printLine "arr[pos]++;"
printChar '-' = printLine "arr[pos]--;"
printChar '>' = printLine "pos++;"
printChar '<' = printLine "pos--;"
printChar '[' = do
  printLine "while(arr[pos]) {"
  incrementTabs
printChar ']' = do
  decrementTabs
  printLine "}"

writeInput :: GlobalState ()
writeInput = do
  end <- isEnd
  if end then return ()
    else do
      ch <- consumeInput
      printChar ch
      writeInput

checkBrackets :: String -> [Char] -> Bool
checkBrackets [] [] = True
checkBrackets [] (b:bs) = False
checkBrackets (b:bs) [] = checkBrackets bs [b]
checkBrackets ('[':bs) (']':xs) = False
checkBrackets (']':bs) ('[':xs) = checkBrackets bs xs
checkBrackets (b:bs) (xs) = checkBrackets bs (b:xs)

checkInput :: String -> Bool
checkInput str
  | checkBrackets (filter (\x -> x `elem` "[]") str) [] = True
  | otherwise = error "Mismatched brackets found"

writeProgram :: GlobalState ()
writeProgram = do
  printInitialComments
  printIncludes
  printLine "int main(void)"
  printLine "{"
  incrementTabs
  printLine "int pos = 0;"
  printAllocateArray
  writeInput
  decrementTabs
  printLine "}"

runCompiler :: String -> String -> IO ()
runCompiler prog filename = do
  when (not (hasExtension filename)) $ error "Please save the source code to a valid brainfuck file extension file"
  putStrLn "Checking syntax"
  let check = checkInput prog
  if check == False then putStrLn "Syntax check failed"
    else putStrLn "Syntax check successful"
  let cfile = addExtension (dropExtension filename) ".c"
  putStrLn $ "translating program and writing to: " ++ cfile
  han <- openFile cfile WriteMode
  _ <- runStateT writeProgram (Global han 0 prog)
  hClose han
  let cmd = "gcc -O3 " ++ cfile ++ " -o " ++ (dropExtension filename)
  putStrLn $ "compiling program with command: " ++ cmd
  callCommand cmd
  putStrLn $ "wrote finished program to file: " ++ (dropExtension filename)
